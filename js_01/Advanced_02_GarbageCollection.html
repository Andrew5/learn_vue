<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 栈（操作系统）：由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面。
        // 堆（操作系统）：一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面。 
        // 闭包：实现数据私有，当一个函数内部定义了另一个函数，并且这个内部函数可以访问外部函数的变量时，就形成了闭包
        let i = 0;
        function outer() {
            i++
            function fn() {
                console.log(`函数被调用了${i}次`);
            }
            return fn
        }
        //    outer() === fn === function fn(){}
        const fun = outer()
        fun()

        // 1、把所有var声明的变量提升到当前作用域的最前面
        // 只提升声明，不提升赋值

        // 动态参数
        function push(array, ...items) {
            array.push(...items)
            console.log(`数组集合:${array}`);
        }
        // 如何调用这个push
        let arr = [1, 2, 3]
        push(arr, 4, 5, 6)

        // 求和
        // sum 函数现在接受一个初始值 initial 和任意数量的其他参数 ...items。
        // 使用 reduce 方法来累加 items 数组中的所有元素。
        // reduce 方法的第一个参数是一个回调函数，该回调函数的第一个参数 accumulator 是累加器的当前值，第二个参数 currentValue 是 items 数组中的当前元素。
        // reduce 方法的第二个参数 initial 是累加器的初始值，它对应于 sum 函数的第一个参数。
        const sum = function (initial, ...items) {
            return items.reduce((accumulator, currentValue) => accumulator + currentValue, initial);
        }
        const result1 = sum(1, 2, 3, 4, 5); // 传入四个参数  
        console.log(`四个参数 + ${result1}`); // 输出：10  


        function getSum() {
            let sum = 0
            // arguments 动态参数 只存在于 函数里面
            for (let i = 0; i < arguments.length; i++) {
                sum += arguments[i]
            }
            console.log(`我的和是 ${sum}`);
            return sum
        }
        const sum1 = getSum(1, 2, 3, 4)
        console.log(`1我的和是 ${sum1}`);        
    </script>
</body>

</html>